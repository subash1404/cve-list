const https = require("https");
const { MongoClient } = require("mongodb");
require('dotenv').config();
const mongoUri =
  process.env.MONGO_URI;
const dbName = "cveDatabase";
const collectionName = "cves";

const fetchCves = (startIndex = 0, resultsPerPage = 2000) => {
  return new Promise((resolve, reject) => {
    const apiUrl = `${process.env.BASE_API}?resultsPerPage=${resultsPerPage}&startIndex=${startIndex}`;
    https
      .get(apiUrl, (res) => {
        let data = "";
        res.on("data", (chunk) => {
          data += chunk;
        });
        res.on("end", () => {
          try {
            resolve(JSON.parse(data));
          } catch (error) {
            reject(error);
          }
        });
      })
      .on("error", (error) => {
        reject(error);
      });
  });
};

const syncCves = async (isFullRefresh = true) => {
  const client = new MongoClient(mongoUri);
  try {
    await client.connect();
    console.log("Connected to the database");
    const db = client.db(dbName);
    const collection = db.collection(collectionName);

    if (isFullRefresh) {
      await collection.deleteMany({});
      console.log("Deleted Existing collections");
    }

    let startIndex = 0;
    const resultsPerPage = 2000;

    while (true) {
      const data = await fetchCves(startIndex, resultsPerPage);
      if (!data.vulnerabilities || data.vulnerabilities.length === 0) break;

      const cves = data.vulnerabilities.map((vulnerability) => ({
        cveId: vulnerability.cve.id,
        sourceIdentifier: vulnerability.cve.sourceIdentifier,
        published: new Date(vulnerability.cve.published),
        lastModified: new Date(vulnerability.cve.lastModified),
        vulnStatus: vulnerability.cve.vulnStatus,
      }));

      await collection.insertMany(cves);
      console.log(`Inserted 2000 CVEs from index ${startIndex} to ${startIndex+2000}`);
      startIndex += resultsPerPage;
    }
  } catch (error) {
    console.error("Error synchronizing CVEs:", error);
  } finally {
    await client.close();
  }
};

const scheduleSync = () => {
  const oneDayInMs = 24 * 60 * 60 * 1000;
  const nextRun = 60 * 1000; // For testing: set to 1 minute.
  console.log(`Next sync scheduled in ${nextRun/1000/60} minute(s)`);
  setTimeout(() => {
    syncCves(true).then(() => {
      setInterval(() => syncCves(true), oneDayInMs);
    });
  }, nextRun);
};

scheduleSync();
