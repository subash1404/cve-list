
require("dotenv").config();
function formatDateTime(dateTimeString) {
  const date = new Date(dateTimeString);
  const formattedDate = date.toLocaleDateString().replaceAll("/", "-");
  const formattedTime = date.toLocaleTimeString();
  return `${formattedDate} ${formattedTime}`;
}

function getCvesList(req, res, parsedUrl) {
  const queryParams = parsedUrl.query;
  const page = parseInt(queryParams.page, 10) || 1;
  const itemsPerPage = parseInt(queryParams.itemsPerPage, 10) || 10; 
  const filterType = queryParams.filterType;
  const filterValue = queryParams.filterValue;
  const sortOrder = queryParams.sortOrder;
  const startIndex = (page - 1) * itemsPerPage;

  let apiUrl = `${process.env.BASE_API}?resultsPerPage=${itemsPerPage}&startIndex=${startIndex}`;

  if (filterType && filterValue) {
    if (filterType === "cveId") {
      apiUrl += `&cveId=${filterValue}`;
    } else if (filterType === "year") {
      apiUrl += `&lastModStartDate=${filterValue}-08-04T13:00:00.000%2B01:00&lastModEndDate=${filterValue}-10-22T13:36:00.000%2B01:00`;
    } else if (filterType === "CVSSv2") {
      apiUrl += `&cvssV2Metrics=${filterValue}`;
    } else if (filterType === "CVSSv3") {
      apiUrl += `&cvssV3Metrics=${filterValue}`;
    }
  }

  fetch(apiUrl)
    .then((response) => {
      if (!response.ok) {
        throw new Error("Failed to fetch data");
      }
      return response.json();
    })
    .then((data) => {
      let cves = data.vulnerabilities.map((vulnerability) => ({
        id: vulnerability.cve.id,
        identifier: vulnerability.cve.sourceIdentifier,
        published: formatDateTime(vulnerability.cve.published),
        lastModified: formatDateTime(vulnerability.cve.lastModified),
        status: vulnerability.cve.vulnStatus,
      }));

      if (sortOrder === "desc") {
        cves = cves.reverse();
      }

      const cveLength = data.totalResults;
      res.writeHead(200, { "Content-Type": "application/json" });
      res.end(
        JSON.stringify({
          cveLength,
          cves,
          totalPages: Math.ceil(cveLength / itemsPerPage),
        })
      );
    })
    .catch((error) => {
      console.error("Error fetching data:", error);
      res.writeHead(500, { "Content-Type": "text/plain" });
      res.end("Error fetching data");
    });
}

function getCveDetails(req, res, parsedUrl) {
  const query = parsedUrl.query;
  const cveId = query.cveId;
  if (!cveId) {
    res.writeHead(400, { "Content-Type": "text/plain" });
    res.end("CVE ID is required");
    return;
  }

  fetch(`${process.env.BASE_API}?cveId=${cveId}`)
    .then((response) => {
      if (!response.ok) {
        throw new Error("Failed to fetch CVE details");
      }
      return response.json();
    })
    .then((data) => {
      const cve = data.vulnerabilities[0].cve;
      const { id, descriptions, metrics, configurations } = cve;
      const description = descriptions.find((desc) => desc.lang === "en");
      const cvssMetricV2 = metrics.cvssMetricV2[0].cvssData;

      const responseData = {
        id,
        description: description.value,
        cvssMetricV2,
        metrics,
        configurations,
      };

      res.writeHead(200, { "Content-Type": "application/json" });
      res.end(JSON.stringify(responseData));
    })
    .catch((error) => {
      console.error("Error fetching CVE details:", error);
      res.writeHead(500, { "Content-Type": "text/plain" });
      res.end("Error fetching CVE details");
    });
}

module.exports = {
  getCvesList,
  getCveDetails,
};
